r"""
A collection of functions meant to parse information about rhythmic
and melodic difficulty from files generated by APOPCALEAPS.
"""


import argparse
import logging
import os
import pickle

from math import log

from music21.converter import parse
from music21.interval import notesToChromatic
from music21.note import Note, Rest

import pykov
from pykov import maximum_likelihood_probabilities


from sight_reading.conversion.midi_handling import extract_melody_measures


LOG = logging.getLogger(__name__)


def _assemble_measures(full_path):
    r"""
    Return a list of all the measures present in a generated midi.

    #. `full_path`: the absolute path to the generated midi file
    """
    piece = parse(full_path)
    # range is exclusive, so 13 + 1
    measures = [m for m in extract_melody_measures(piece, range(1, 13 + 1))]
    return measures


def _measure_rhythms(measure):
    r"""
    Return a list of all the rhythm events (as strings) in a supplied measure.

    #. `measure`: a music21 `Stream` directly containing notes/rests/...
    """
    rhythms = []
    measure_offset = None
    for element in measure:
        if isinstance(element, Note) or isinstance(element, Rest):
            rhythms.append((element.offset,
                            element.quarterLength,
                            isinstance(element, Note)))
    # little patch to ensure consistency:
    # APOPCALEAPS output normally does not add last rests in final measure
    if round(rhythms[-1][0] + rhythms [-1][1], 2) != 5.0:
        start = rhythms[-1][0] + rhythms[-1][1]
        rhythms.append((start, 5.0 - start, False))
    return ['BEGINNING_OF_MEASURE'] + rhythms + ['END_OF_MEASURE']


def _measure_melodies(measure):
    r"""
    Return a list of all the melody events (as strings) in a supplied measure.

    #. `measure`: a music21 `Stream` directly containing notes/rests/...
    """
    entries = []
    for element in measure:
        if isinstance(element, Note):
            if entries:
                step = notesToChromatic(last_note, element).semitones
                prev_entry = entries[-1]
                entries.append((prev_entry[1], prev_entry[2], step))
            else:
                entries.append((0, 0, 0))  # first note means no interval
            last_note = element
    return ['BEGINNING_OF_SEQUENCE'] + entries + ['END_OF_SEQUENCE']


def _measure_melodies_mixed(measure, key, chord):
    r"""
    Return a list of all the melody events (as strings) in a supplied measure.

    #. `measure`: a music21 `Stream` directly containing notes/rests/...
    """
    entries = []

    key_obj = music21.key.Key(key)
    if key == 'minor':
        key_pitch = music21.pitch.Pitch('a')
    elif key == 'major':
        key_pitch = music21.pitch.Pitch('c')
    if chord[-1] == 'm':
        chord = chord[:-1]
    chord_pitch = music21.pitch.Pitch(chord)

    for element in measure:
        if isinstance(element, Note):
            if entries:
                prev_entry = entries[-1]
                interval = notesToChromatic(last_note, element)
                entry = (prev_entry[1], notestToChromatic(last_note, element).semitones,
                         notesToChromatic(key_pitch, element).semitones, key,
                         notesToChromatic(key_pitch, chord_pitch).semitones)
            else:
                entries = [(0, 0, notesToChromatic(key_pitch, element).semitones, key,
                            notesToChromatic(key_pitch, chord_pitch).semitones)]
        last_note = element

    return ['BEGINNING_OF_SEQUENCE'] + entries + ['END_OF_SEQUENCE']


def find_difficulties(sample_dir_path, r_chain_path, m_chain_path, output_path):
    r"""
    `sample_dir_path`: the path to the directory containing samples
    `r_chain_path`: the path to the pickled rhythm chain used
    `m_chain_path`: the path to the pickled melody chain used
    `output_path`: the path to a file in which results will be pickled
    
    Note that result is encoded as a list of tuples, each of which
    represents the likelihood of the rhythm and melody (respectively)
    of a single measure.

    This function also assumes that samples are being taken, implying
    that measures are uncorrelated.
    """
    with open(r_chain_path, 'rb') as fh:
        r_chain = pickle.load(fh)
        _, r_chain = maximum_likelihood_probabilities(r_chain)
    with open(m_chain_path, 'rb') as fh:
        m_chain = pickle.load(fh)
        _, m_chain = maximum_likelihood_probabilities(m_chain)

    results = []
    samples = os.listdir(sample_dir_path)
    for sample_num, sample_path in enumerate(samples, start=1):
        LOG.info('{num} of {total}'.format(num=sample_num, total=len(samples)))
        full_path = os.path.join(sample_dir_path, sample_path)
        measures = _assemble_measures(full_path)
        # note that closing measures are ignored because they are simpler
        for m_count, measure in enumerate(measures[0:12], start=1):
            LOG.info('{num} of {total}'.format(num=m_count, total=12))
            likelihood_rhythm = _log_likelihood([str(rhythm) for rhythm in _measure_rhythms(measure)], r_chain)[0]
            likelihood_melody = _log_likelihood([str(melody) for melody in _measure_melodies(measure)], m_chain)[0]
            results.append((likelihood_rhythm, likelihood_melody))
    with open(output_path, 'wb') as fh:
        pickle.dump(results, fh, pickle.HIGHEST_PROTOCOL)

            
def _log_likelihood(entries, original_chain):
    r"""
    Find the log likelihood of a sequence of entries, given a Markov
    chain representing a corpus.

    #. `entries`: a sequence of events in the part, in string form
    #. `original_chain`: the pykov chain used to evaluate likelihood
    """
    state = entries[0]
    log_likelihood = 0
    _, local_chain = maximum_likelihood_probabilities(entries)
    mod_chain = alt_combine_markov_chains(original_chain, local_chain, 0.02)
    for entry in entries[1:]:
        successors = mod_chain.succ(state)
        log_likelihood += log(mod_chain.succ(state)[entry])
        state = entry
    return log_likelihood, mod_chain


def _multi_log_likelihoods(sequence_entries, original_chain):
    r"""
    For each sequence of entries, yield the log likelihood.

    This function assumes the entries supplied are the only ones which
    are relevant, and that they are encountered sequentially.
    That is, if, say, the contents of the first and third
    measure generated affect the likelihood of the fourth and if the
    second measure should be ignored, the sequence of sequences contains
    only the sequences for the first and third generated measures.

    #. `sequence_entries`: a sequence of sequences of events in the part
    #. `original_chain`: the pykov chain representing the corpus likelihoods
    """
    # first one is just _log_likelihood; second is _log_likelihood, but using mixed chain
    next_chain = original_chain
    for sequence in sequence_entries:
        likelihood, next_chain = _log_likelihood(sequence, next_chain)
        yield likelihood


def _alt_supplement_chain(supplemented, supplemented_keys,
                          supplemented_start_keys, supplementer,
                          supplementer_keys, supplementer_start_keys):
    r"""
    Make sure `supplemented` has a superset of the keys of `supplementer`.

    Markov chains can only be combined linearly if they have the same keys.
    This changes `supplemented` in place so that it either copies information
    or creates zero-entries for transitions, depending on the information it
    already possesses.
    """
    missing_keys = supplementer_keys - supplemented_keys
    missing_start_keys = supplementer_start_keys - supplemented_start_keys

    for missing in missing_keys:
        if missing[0] in missing_start_keys:
            supplemented[missing] = supplementer[missing]
        else:
            supplemented[missing] = 0.0


def alt_combine_markov_chains(main, adjustment, alpha):
    r"""
    Takes two Pykov chains and creates a linear combination of them.

    #. `main_chain`: the starting point for the combined chain
    #. `adjustment_chain`: steers the output away from `main_chain`
    #. 0 < `adjustment` < 0.5: the magnitude of the adjustment

    **Note: name is due to improvement over older version.**
    """
    LOG.debug('Main chain: {m}'.format(m=main))
    main_copy = pykov.Chain(main)
    adjustment_copy = pykov.Chain(adjustment)

    main_keys = set((key for key in main))
    adjustment_keys = set((key for key in adjustment))
    main_start_keys = set((key[0] for key in main_keys))
    adjustment_start_keys = set((key[0] for key in adjustment_keys))

    _alt_supplement_chain(main_copy, main_keys, main_start_keys,
                          adjustment_copy, adjustment_keys,
                          adjustment_start_keys)
    _alt_supplement_chain(adjustment_copy, adjustment_keys,
                          adjustment_start_keys,
                          main_copy, main_keys, main_start_keys)
    return (1 - alpha) * main_copy + alpha * adjustment_copy



if __name__ == '__main__':

    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument('sample_dir', help='the directory containing samples to be analyzed')
    arg_parser.add_argument('pickled_rhythm', help='the directory containing the pickled rhythm chain')
    arg_parser.add_argument('pickled_melody', help='the directory containing the pickled melody chain')
    arg_parser.add_argument('output_path', help='where to pickle the list of tuples with measure stats')
    explanation = "'Relative', 'Mixed' or 'Temperley' determines algorithm "\
                  "used to evaluate melodic difficulty. Default: 'Relative'" 
    arg_parser.add_argument('mode', help=explanation)
    args = arg_parser.parse_args()
    mode = args.mode
    if mode:
        assert mode in ['Relative', 'Mixed', 'Temperley']
    else:
        mode = 'Relative'

    args = arg_parser.parse_args()
    find_difficulties(args.sample_dir, args.pickled_rhythm,
                      args.pickled_melody, args.output_path)
